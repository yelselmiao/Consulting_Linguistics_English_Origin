---
title: "Code for English Origin"
output: github_document
editor_options: 
  chunk_output_type: inline
---


Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r install pkg}
install.packages('ggpubr')
```



```{r Load Package}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(rstatix))
suppressPackageStartupMessages(library(ggpubr))
suppressPackageStartupMessages(library(rlang))
suppressPackageStartupMessages(library(gridExtra))



`%notin%` <- Negate(`%in%`)
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```



```{r read data}
raw_data <- readxl::read_excel("/Users/shuyitan/Desktop/Consulting/Consulting_Linguistics_English_Origin/Data/Rap_data_Final.xlsx", sheet = 'MUEV+MIEV', skip = 1)
```

# Summary Stats

```{r Str data}
str(raw_data)
```

Purpose: to investigate the use of English-origin verb

Dependent variable: 
MUEV or MIEV  


Interested question: 
- if there are more MUEV in the Dictionnaire du Chilleur compared to the Fonds de données linguistiques du Québec  
- It might be interesting to look at the band `Dead Obies` separately from (or in comparison with) the other bands. They use the MUEV much more I think and they use more English words in their lyrics – they are typically known and criticized for that. 




For the factor Following Sound and the factor Final Sound of Verb (below in the table), the levels might need to be grouped. But there is a way to grouped them logically in linguistics. If they behave similarly and present to distinctive “behaviours”, here’s how they could be grouped: stop + nasal, fricative + affricate, stop + nasal + fricative + affricate, approximant + lateral approximant. Vowel and Zero need to stay alone, they can’t be grouped. 




```{r MUEV or MIEV}
n_distinct(data$`Artist/band...1`)

n_distinct(data$Title)


nrow(data)


table(data$`MUEV or MIEV`)


raw_data %>% 
  group_by(`MUEV or MIEV`) %>% 
  tally(name = "Count") %>% 
  mutate(Percentage = round(Count / sum(Count) * 100, digits = 1)) %>% 
  arrange(desc(Count))
```



```{r Count of Band}
raw_data %>% 
  group_by(`Artist/band...1`) %>% 
  tally(name = "Count") %>% 
  mutate(Percentage = round(Count / sum(Count) * 100)) %>% 
  arrange(desc(Count))
```



```{r count verb}
raw_data %>%  
  group_by(Verb) %>%  
  tally() %>%  
  arrange(desc(n)) 


raw_data %>%  
  group_by(`Regular or irregular V in Eng`) %>%  
    tally(name = "Count") %>% 
  mutate(Percentage = round(Count / sum(Count) * 100, digits = 1)) %>% 
  arrange(desc(Count))
```


```{r Word frequency}
aggregated_words <- raw_data %>%
  group_by(Verb) %>%
  tally() %>%
  arrange(desc(n))

# Create a separate label for words with the same count
# Aggregate them into a single string (e.g., "word1, word2, ...")
aggregated_words <- aggregated_words %>%
  group_by(n) %>%
  summarise(words = paste(Verb, collapse = ", ")) %>%
  arrange(desc(n)) 



data_frame(aggregated_words)
aggregated_words

# aggregated_words <- aggregated_words %>%  
#   top_n(5)
# 
# # Plot the data
# ggplot(aggregated_words, aes(x = reorder(words, n), y = n)) +
#   geom_bar(stat = "identity") +
#   geom_text(aes(label = n), vjust = -0.5) + # Add count labels
#   coord_flip() + # Optional: to flip coordinates for better readability
#   labs(title = "Words with Top Counts",
#        x = "Words",
#        y = "Count") +
#   theme_minimal()
```

```{r Relative Postion - summary stat}
range(data$`Relative position in phrase`)
mean(data$`Relative position in phrase`)
median(data$`Relative position in phrase`)
```





```{r relative position (density plot)}
rp_density <- ggplot(raw_data, aes(x = `Relative position in phrase`)) +
  geom_density(fill = "blue", alpha = 0.4) +
  labs(
    #title = "Density Plot of Relative Position in the Phrase",
    x = "Relative Position in Phrase",
    y = "Density"
  ) +
  theme_minimal() #+ 
  #theme(plot.subtitle = element_text(size = 5))

rp_density  
```



```{r Position of verb in phrase}
# Convert the column to a factor with the desired order
raw_data <- raw_data %>%
  mutate(`Position of verb in phrase` = factor(
    `Position of verb in phrase`, 
    levels = c("beginning", "middle", "end")
  ))

# Calculate counts and percentages
data_summary <- raw_data %>%
  group_by(`Position of verb in phrase`) %>%
  tally(name = "Count") %>%
  mutate(Percentage = round(Count / sum(Count) * 100, digits = 1)) %>%
  arrange(desc(Count)) 
```


```{r verb position (bar plot)}
# Create the bar plot
rp_bar <- ggplot(data_summary, aes(x = `Position of verb in phrase`, y = Count)) +
  geom_bar(stat = "identity", fill = "blue", color = "black", alpha = 0.7) +
  geom_text(
    aes(label = paste0(Count, " (", Percentage, "%)")), 
    vjust = -0.5, 
    size = 4
  ) +
  labs(
    #title = "Bar Plot of Position of Verb in Phrase",
    x = "Position of Verb in Phrase",
    y = "Frequency"
  ) +
  theme_minimal() #+
  #theme(plot.subtitle = element_text(size = 5))

rp_bar
```



```{r following sound count}
raw_data %>% 
  group_by(`Following sound`) %>%  
  tally(name = "Count") %>% 
  mutate(Percentage = round(Count / sum(Count) * 100, digits = 1)) %>% 
  arrange(desc(Count))
```
check if significantly more 

grouping 

But there is a way to grouped them logically in linguistics. If they behave similarly and present to distinctive “behaviours”, here’s how they could be grouped: stop + nasal, fricative + affricate, stop + nasal + fricative + affricate, approximant + lateral approximant. Vowel and Zero need to stay alone, they can’t be grouped. 


```{r add following sound grouping}
data <- raw_data %>%  
  mutate(
    SoundGroup_1 = case_when(
      `Following sound` %in% c("stop", "nasal") ~ "stop + nasal",
      `Following sound` %in% c("fricative", "affricate") ~ "fricative + affricate",
      #`Following sound` %in% c("stop", "nasal", "fricative", "affricate") ~ "stop + nasal + fricative + affricate",
      `Following sound` %in% c("approximant", "lateral approximant") ~ "approximant + lateral approximant",
      `Following sound` %in% c("vowel", "zero") ~ `Following sound`, # Keep "vowel" and "zero" as is
      TRUE ~ "Other" # For any unexpected value
    ) ,
    SoundGroup_2 = case_when( 
      `Following sound` %in% c("stop", "nasal", "fricative", "affricate") ~ "stop + nasal + fricative + affricate", 
      `Following sound` %in% c("approximant", "lateral approximant") ~ "approximant + lateral approximant",
      `Following sound` %in% c("vowel", "zero") ~ `Following sound`, #  
      TRUE ~ "Other" # For any unexpected value
    )
  )

```

```{r additional followinh sound count}
data %>% 
  group_by(`SoundGroup_1`) %>%  
  tally()


data %>% 
  group_by(`SoundGroup_2`) %>%  
  tally()
```



```{r sound group visual}

ggplot(data, aes(x = SoundGroup_1)) +
  geom_bar(fill = "blue", color = "black", alpha = 0.7) +
  labs(
    title = "Bar Chart of SoundGroup_1",
    x = "Sound Group",
    y = "Count"
  ) +
  theme_minimal() + 
    theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )



ggplot(data, aes(x = SoundGroup_2)) +
  geom_bar(fill = "blue", color = "black", alpha = 0.7) +
  labs(
    title = "Bar Chart of SoundGroup_1",
    x = "Sound Group",
    y = "Count"
  ) +
  theme_minimal() + 
    theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```
```{r following sound visual}


# Precompute counts and percentages, and order by count
data_summary <- data %>%
  count(`Following sound`, name = "n") %>%
  mutate(
    percentage = n / sum(n) * 100, # Calculate percentage
    `Following sound` = factor(`Following sound`, levels = `Following sound`[order(-n)]) # Order factor
  )

# Create the bar plot with labels
ggplot(data_summary, aes(x = `Following sound`, y = n)) +
  geom_bar(stat = "identity", fill = "blue", color = "black", alpha = 0.7) +
  geom_text(
    aes(label = paste0(n, " (", round(percentage, 1), "%)")), # Add count and percentage
    vjust = -0.5, size = 3
  ) +
  labs(
    title = "Following Sound",
    x = "Sound Group",
    y = "Count"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = -15, hjust = 0.2)
  )

```

```{r following sound - stacked visual - horizontal}

data_summary <- data %>% 
  group_by(`SoundGroup_1`, `Following sound`) %>%  
  tally()

ggplot(data_summary, aes(x = SoundGroup_1, y = n, fill = `Following sound`)) +
  geom_bar(stat = "identity", position = "stack", alpha = 0.8, color = "black") +
  geom_text(
    aes(
      label = ifelse(n > 5, paste0(`Following sound`, ": ", n), ""), # Only show labels if n > 5
      vjust = ifelse(n > 20, 0.5, -0.5) # Adjust vertical alignment for small segments
    ),
    position = position_stack(vjust = 0.5),
    size = 3
  ) +
  labs(
    title = "Stacked Bar Chart of Sound Groups with Counts",
    x = "Sound Group",
    y = "Count",
    fill = "Following Sound"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "top"
  )
```




```{r following sound - stacked visual - vertical}
ggplot(data_summary, aes(y = SoundGroup_1, x = n, fill = `Following sound`)) + 
  geom_bar(stat = "identity", position = "stack", alpha = 0.8, color = "black") + 
  geom_text( 
    aes( 
      label = case_when( 
        SoundGroup_1 == "fricative + affricate" & `Following sound` == "affricate" ~ paste0("affricate: ", n), 
        SoundGroup_1 == "approximant + lateral approximant" & `Following sound` == "approximant" ~ paste0("approximate: ", n), 
        n > 5 ~ paste0(`Following sound`, ": ", n), # Generic labels for other groups 
        TRUE ~ "" # Do not label very small values 
      ), 
      x = case_when(
        `Following sound` == "affricate" ~ n + 18, # Move only affricate labels
        `Following sound` == "approximant" ~ n + 25, # Move only approximate labels
        TRUE ~ n # Default no adjustment
      ) 
    ), 
    position = position_stack(vjust = 0.5), 
    size = 3 
  ) + 
  labs( 
   # title = "Count of Following Sounds", 
    x = "Count", 
    y = "Sound Group", 
    fill = "Type of Following Sound" 
  ) + 
  theme_minimal() + 
  theme( 
    legend.position = "top" ,
    legend.text = element_text(size = 7.5)
  )
```



```{r other english item}
data %>%  
  group_by(`Presence of other English items in phrase`) %>% 
  tally(name = "Count") %>% 
  mutate(Percentage = round(Count / sum(Count) * 100, digits = 1)) %>% 
  arrange(desc(Count))
```
check the pattern along with other linguistic factors 

```{r eng morphology}
data %>%  
  group_by(`Would have ENG morphology`) %>% 
  tally(name = "Count") %>% 
  mutate(Percentage = round(Count / sum(Count) * 100, digits = 1)) %>% 
  arrange(desc(Count))
```
```{r In dictionary}
data <- data %>%  
    mutate(
    `In Fonds de données linguistiques du Québec (FDLQ)` = as.logical(`In Fonds de données linguistiques du Québec (FDLQ)`)
  )


data %>%  
  summarize(     
    DC_TRUE = sum(`In Dictionnaire du Chilleur (DC)`),     
    FDLQ_TRUE = sum(`In Fonds de données linguistiques du Québec (FDLQ)`),     
    Both_TRUE = sum(`In Dictionnaire du Chilleur (DC)` & `In Fonds de données linguistiques du Québec (FDLQ)`),     
    Total = nrow(data) # Use nrow(data) instead of summing counts
  ) %>% 
  mutate(
    Percent_DC_TRUE = DC_TRUE / Total * 100,
    Percent_FDLQ_TRUE = FDLQ_TRUE / Total * 100,
    Percent_Both_TRUE = Both_TRUE / Total * 100,
    DC_Pct = paste0(DC_TRUE, " (", round(Percent_DC_TRUE, 2), "%)"),
    FDLQ_Pct = paste0(FDLQ_TRUE, " (", round(Percent_FDLQ_TRUE, 2), "%)"),
    Both_Pct = paste0(Both_TRUE, " (", round(Percent_Both_TRUE, 2), "%)")
  )

```



```{r Verb Category}
data <- data %>%
  mutate(verb_def = case_when(
    `Verb category` == 1 ~ "simple verb",
    `Verb category` == 3 ~ "closed vowel + semivowel",
    `Verb category` == 4 ~ "final syllabic [l])",
    `Verb category` == 5 ~ "homophony, zero derivation, truncated, verlanized, or borrowed as is",
    `Verb category` == 6 ~ "simple verb – always unintegrated",
    TRUE ~ NA_character_  # Default case
  ))

data %>%
  group_by(`Verb category`, verb_def) %>%
  tally(name = "Count") %>% 
  mutate(Percentage = round(Count / nrow(data) * 100, digits = 1)) %>% 
  arrange(desc(Count))

                  

```


```{r Final Sound}
data %>%
  group_by(`Final sound`) %>%
  tally(name = "Count") %>% 
  mutate(Percentage = round(Count / nrow(data) * 100, digits = 1)) %>% 
  arrange(desc(Count))
```

# Group Comparision

```{r regularity}
table_regularity <- table(data$`MUEV or MIEV`, data$`Regular or irregular V in Eng`)
table_regularity
chisq.test(table_regularity)

# fisher.test(table_regularity)


prop.table(table_regularity, margin = 2)  # Column-wise proportion
prop.table(table_regularity, margin = 1)  # Row-wise proportion
```
```{r presence of other English}
tb_present_other_e <- table(data$`MUEV or MIEV`, data$`Presence of other English items in phrase`)
tb_present_other_e
chisq.test(tb_present_other_e)



prop.table(tb_present_other_e, margin = 2)  # Column-wise proportion
prop.table(tb_present_other_e, margin = 1)  # Row-wise proportion
```




```{r English morpholology - chi sq}
tb_morphology <- table(data$`MUEV or MIEV`, data$`Would have ENG morphology`)
tb_morphology
chisq.test(tb_morphology)
```
```{r English morpholology-viz }
# Convert the contingency table into a data frame
tb_morphology_df <- as.data.frame(as.table(tb_morphology))

# Rename the columns for better readability
colnames(tb_morphology_df) <- c("Dependent", "Independent", "Count")


# Perform the chi-squared test again
test_result <- chisq.test(tb_morphology)
test_result

# Create a grouped bar plot
ggplot(tb_morphology_df, aes(x = Independent, y = Count, fill = Dependent)) +
  geom_bar(stat = "identity", position = "dodge") +
    geom_text(
    aes(label = Count),
    position = position_dodge(width = 0.9),
    vjust = 0.1,
    size = 4
  ) +
  
  labs(
    # title = "Chi-squared Test Visualization",
    # subtitle = paste(
    #   "Chi-squared = ", round(test_result$statistic, 2),
    #   ", p-value = ", format.pval(test_result$p.value, digits = 3, eps = 0.001)
    # ),
    x = "Would have ENG Morphology",
    y = "Count",
    fill = "MUEV or MIEV"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    legend.position = "top"
  ) +
  scale_fill_brewer(palette = "Set2")
```

```{r English morpholology-pairwise}

tb_mor <- table(data$`Would have ENG morphology`, data$`MUEV or MIEV`)
pairwiseNominalIndependence(tb_mor, method = "fdr")



tb_mor <- table(data$`MUEV or MIEV`, data$`Would have ENG morphology`)
pairwiseNominalIndependence(tb_mor, method = "fdr")


chisq.test(tb_morphology)

```



```{r Position of verb - test and Viz}
# Create a contingency table
tb_position <- table(data$`MUEV or MIEV`, data$`Position of verb in phrase`)

# Convert the contingency table into a data frame
tb_position_df <- as.data.frame(as.table(tb_position))

# Rename the columns for better readability
colnames(tb_position_df) <- c("Dependent", "Independent", "Count")


# Order the Independent variable to reflect the ranked levels
tb_position_df$Independent <- factor(tb_position_df$Independent, levels = c("beginning", "middle", "end"))

# Perform Fisher's Exact Test
fisher_result <- fisher.test(tb_position)


ggplot(tb_position_df, aes(x = Independent, y = Count, fill = Dependent)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(
    aes(label = Count),
    position = position_dodge(width = 0.9),
    vjust = 0.1,
    size = 4
  ) +
  labs(
    #title = "Comparison of MUEV or MIEV with Position of Verb in Phrase",
    # subtitle = paste(
    #   "Fisher's Exact Test p-value = ",
    #   format.pval(fisher_result$p.value, digits = 3, eps = 0.001)
    # ),
    x = "Position of Verb in Phrase",
    y = "Count",
    fill = "MUEV or MIEV"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    legend.position = "top"
  ) +
  scale_fill_brewer(palette = "Set2")
```


```{r}
pairwise_fisher_test(tb_position, p.adjust.method = "bonferroni")
```



```{r}
tb_position_2 <- table(data$`Position of verb in phrase`, data$`MUEV or MIEV`)

fisher.test(tb_position_2)

pairwise_fisher_test(tb_position, p.adjust.method = "bonferroni")

pairwise_fisher_test(tb_position_2, p.adjust.method = "bonferroni")

```






```{r Relative Position - correlation}
# The point biserial correlation quantifies the strength and direction of the relationship between the continuous variable (Relative position in phrase) and the binary dependent variable (MUEV or MIEV).


cor_result <- cor.test(data$`Relative position in phrase`, data$`MUEV or MIEV`)

cor_result

# There is a statistically significant weak positive correlation between Relative position in phrase and MUEV or MIEV (with a correlation coefficient of 0.206), suggesting that as the relative position of the verb in the phrase changes, the occurrence of MUEV increases slightly.


# The positive correlation coefficient of 0.206 suggests that as the relative position of the verb in the phrase increases, the likelihood of MUEV (coded as 1) also increases. In other words, a higher relative position of the verb in the phrase is associated with an increased likelihood of the event corresponding to MUEV. So, the direction of the change is an increase in MUEV as the relative position of the verb in the phrase increases.
```




```{r}
shapiro.test(data$`Relative position in phrase`)
ks.test(data$`Relative position in phrase`, "pnorm", mean(data$`Relative position in phrase`), sd(data$`Relative position in phrase`))
```



```{r}
data <- data %>%
  mutate(`Position of verb in phrase` = factor(`Position of verb in phrase`, 
                                                levels = c("beginning", "middle", "end"), 
                                                ordered = TRUE))

# Create a contingency table
contingency_table <- table(data$`Position of verb in phrase`, data$`MUEV or MIEV`)

fisher.test(contingency_table)


mosaicplot(contingency_table, 
           main="Association between Position of Verb in Phrase and MUEV or MIEV",
           color=TRUE)

```


```{r}
# Create a contingency table
contingency_table <- table(data$`Position of verb in phrase`, data$`MUEV or MIEV`)
```

```{r}
tb_fs <- table(data$`Following sound`, data$`MUEV or MIEV`)
fisher.test(tb_fs)

pairwiseNominalIndependence(tb_sg_2, method = "fdr")
```






```{r Following Sound Grouping}
data <- raw_data %>%
  mutate(
    SoundGroup_1 = case_when(
      `Following sound` %in% c("stop", "nasal") ~ "group 1",
      `Following sound` %in% c("fricative", "affricate") ~ "group 2",
      `Following sound` %in% c("approximant", "lateral approximant") ~ "group 3",
      `Following sound` == "vowel" ~ "group 4",
      `Following sound` == "zero" ~ "group 5",
      # "vowel" and "zero" as group 4
      TRUE ~ "Other" 
    ),
    SoundGroup_2 = case_when(
      `Following sound` %in% c("stop", "nasal", "fricative", "affricate") ~ "group 1",
      `Following sound` %in% c("approximant", "lateral approximant") ~ "group 2",
      `Following sound` == "vowel" ~ "group 3",
      `Following sound` == "zero" ~ "group 4",
      # "vowel" and "zero" as group 4
      TRUE ~ "Other"
    )
  )

```






```{r MUEV/MIEV vs SoundGroup_1 - test}
tb_sg_1 <- table(data$`SoundGroup_1`, data$`MUEV or MIEV`)
chisq.test(tb_sg_1)

pw_sg_1 <- pairwiseNominalIndependence(tb_sg_1, method = "fdr")
pw_sg_1 %>% 
  select(Comparison, p.adj.Chisq) %>% 
  mutate(sigficance = ifelse(p.adj.Chisq < 0.05, TRUE, FALSE)) %>% 
  filter(sigficance == TRUE)

# gmodels::CrossTable(data$`SoundGroup_1`, data$`MUEV or MIEV`, chisq = TRUE, expected = TRUE, resid = TRUE)

```

```{r MUEV/MIEV vs SoundGroup_2 - test}
tb_sg_2 <- table(data$`SoundGroup_2`, data$`MUEV or MIEV`)
chisq.test(tb_sg_2)

pw_sg_2 <- pairwiseNominalIndependence(tb_sg_2, method = "fdr")
pw_sg_2 %>% 
  select(Comparison, p.adj.Chisq) %>% 
  mutate(sigficance = ifelse(p.adj.Chisq < 0.05, TRUE, FALSE)) %>% 
  filter(sigficance == TRUE)
```


```{r MUEV/MIEV vs SoundGroup_1 - viz}
# Set up a layout with custom column widths (left plot wider, right plot with more space)
layout(matrix(c(1, 2), nrow = 1, ncol = 2), widths = c(3, 2))  # 3 parts for left plot, 1.5 for right plot

# Create the mosaic plot in the first (wider) space
mosaicplot(SoundGroup_1 ~ `MUEV or MIEV`, data = data,
           main=" ",
           xlab = "Following Sound Group", 
           ylab = "MUEV or MIEV", 
           color = TRUE,  # Use default color
           mar = c(6, 4, 4, 2)  # Adjust margins to make space for the legend
)

# Create the second plot for the legend in the right (slightly wider) space
plot.new()  # Empty plot for legend
legend("center",  # Center the legend in the empty plot
       legend = c("group 1: stop + nasal", 
                  "group 2: fricative + affricate", 
                  "group 3: approximant + lateral approximant", 
                  "group 4: vowel",
                  "group 5: zero"),
       title = "Group Details", 
       xpd = TRUE,  # Ensures the legend stays outside the plot area
       #fill = c("skyblue", "orange", "green", "pink"),  # Custom colors for legend
       border = "black",
       cex = 0.7)  # Add border around legend for clarity

# Reset the layout to default
layout(1)
```


```{r MUEV/MIEV vs SoundGroup_2 - viz}
# Set up a layout with custom column widths (left plot wider, right plot with more space)
layout(matrix(c(1, 2), nrow = 1, ncol = 2), widths = c(3, 2))  # 3 parts for left plot, 1.5 for right plot

# Create the mosaic plot in the first (wider) space
mosaicplot(SoundGroup_2 ~ `MUEV or MIEV`, data = data,
           main=" ",
           xlab = "Following Sound Group", 
           ylab = "MUEV or MIEV", 
           color = TRUE,  # Use default color
           mar = c(6, 4, 4, 2)  # Adjust margins to make space for the legend
)


plot.new()  # Empty plot for legend
legend("center",  # Center the legend in the empty plot
       legend = c("group 1: stop + nasal + fricative + affricate", 
                  "group 2: approximant + lateral approximant", 
                  "group 3: vowel", 
                  "group 4: zero"),
       title = "Group Details", 
       xpd = TRUE,  # Ensures the legend stays outside the plot area
       #fill = c("skyblue", "orange", "green", "pink"),  # Custom colors for legend
       border = "black",
       cex = 0.7)  # Add border around legend for clarity

```


```{r Final Sound Grouping}
data <- data %>%
  mutate(
    FinalSoundGroup_1 = case_when(
      `Final sound` %in% c("stop", "nasal") ~ "group 1",
      `Final sound` %in% c("fricative", "affricate") ~ "group 2",
      `Final sound` %in% c("approximant", "lateral approximant") ~ "group 3",
      `Final sound` == "vowel" ~ "group 4",
      `Final sound` == "zero" ~ "group 5",
      # "vowel" and "zero" as group 4
      TRUE ~ "Other" 
    ),
    FinalSoundGroup_2 = case_when(
      `Final sound` %in% c("stop", "nasal", "fricative", "affricate") ~ "group 1",
      `Final sound` %in% c("approximant", "lateral approximant") ~ "group 2",
      `Final sound` == "vowel" ~ "group 3",
      `Final sound` == "zero" ~ "group 4",
      # "vowel" and "zero" as group 4
      TRUE ~ "Other"
    )
  )
```


```{r}
# Set up a layout with custom column widths (left plot wider, right plot with more space)
layout(matrix(c(1, 2), nrow = 1, ncol = 2), widths = c(5, 4))  # 3 parts for left plot, 1.5 for right plot

# Create the mosaic plot in the first (wider) space
mosaicplot(FinalSoundGroup_2 ~ `MUEV or MIEV`, data = data,
           main=" ",
           xlab = "Finak Sound Group", 
           ylab = "MUEV or MIEV", 
           color = TRUE,  # Use default color
           mar = c(6, 4, 4, 2)  # Adjust margins to make space for the legend
)


plot.new()  # Empty plot for legend
legend("center",  # Center the legend in the empty plot
       legend = c("group 1: stop + nasal + fricative + affricate", 
                  "group 2: approximant + lateral approximant", 
                  "group 3: vowel", 
                  "group 4: zero"),
       title = "Group Details", 
       xpd = TRUE,  # Ensures the legend stays outside the plot area
       #fill = c("skyblue", "orange", "green", "pink"),  # Custom colors for legend
       border = "black",
       cex = 0.7)  # Add border around legend for clarity



```

```{r}
mosaicplot(`In Dictionnaire du Chilleur (DC)`~ `MUEV or MIEV`, data = data,
           main=" ",
           xlab = "Finak Sound Group", 
           ylab = "MUEV or MIEV", 
           color = TRUE,  # Use default color
           mar = c(6, 4, 4, 2))  # Adj
           
           
data$`In Dictionnaire du Chilleur (DC)`
```





```{r Band Dead_Obies}
data <- data %>% 
  mutate(Dead_Obies = ifelse(`Artist/band...1` == 'Dead Obies', 'Dead Obie', 'Other Band/Artist'))

db_tb <- table(data$`MUEV or MIEV`, data$Dead_Obies)

chisq.test(do_tb)

mosaicplot(Dead_Obies ~ `MUEV or MIEV`, data = data,
           main=" ",
           xlab = "Band/Artist", 
           ylab = "MUEV or MIEV", 
           color = TRUE,  # Use default color
           mar = c(6, 4, 4, 2)  # Adjust margins to make space for the legend
)


ggplot(data, aes(x = `Artist/band...1`, fill = `MUEV or MIEV`)) +
  geom_bar(position = "fill") +  # Stacks bars to 100% scale
  scale_y_continuous(labels = scales::percent_format()) +  # Convert y-axis to percentage
  labs(x = "Band or Artist", y = "Percentage", fill = "MUEV vs MIEV") +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  

```


```{r}

band_tb <- table(data$`MUEV or MIEV`, data$`Artist/band...1`)

chisq.test(band_tb)
```

```{r}

# Define the reference band
reference_band <- "Dead Obies"

# Get all other bands in band_tb_filtered
other_bands <- setdiff(colnames(band_tb), reference_band)



# Store results
results <- data.frame(Band = character(), P_Value = numeric(), Test_Type = character(),
                      Significance = character(), Direction = character())

for (band in other_bands) {
  # Extract MUEV counts for Dead Obies and the other band
  muev_counts <- band_tb["MUEV", c(reference_band, band)]
  total_counts <- colSums(band_tb[, c(reference_band, band)])

  # Check if expected counts are too low
  expected_counts <- total_counts * (sum(muev_counts) / sum(total_counts))

  if (any(expected_counts < 5)) {
    # Use Fisher's Exact Test when expected counts are low
    test_result <- fisher.test(band_tb[, c(reference_band, band)])
    test_type <- "Fisher's Exact Test"
  } else {
    # Use Proportion Test when counts are sufficient
    test_result <- prop.test(muev_counts, total_counts)
    test_type <- "Proportion Test"
  }

  # Determine direction of the difference
  prop_dead_obies <- muev_counts[1] / total_counts[1]  # Dead Obies MUEV proportion
  prop_other_band <- muev_counts[2] / total_counts[2]  # Other band's MUEV proportion

  if (prop_dead_obies > prop_other_band) {
    direction <- "More MUEV"
  } else if (prop_dead_obies < prop_other_band) {
    direction <- "Less MUEV"
  } else {
    direction <- "No strong direction"
  }

  # Store results
  results <- rbind(results, data.frame(
    Band = band,
    P_Value = test_result$p.value,
    Test_Type = test_type,
    Significance = ifelse(test_result$p.value < 0.05, "Significant", "Not Significant"),
    Direction = direction
  ))
}

# Print results
results %>% 
  arrange(desc(Significance)) %>% 
  mutate(P_Value = round(P_Value, 2)) %>% 
  filter(Direction == 'Less MUEV') %>% 
  filter(Significance == 'Significant')


 
```



```{r}
# Assuming your data frame is called df

# Create a summary table of MUEV counts by DC and FDLC
muev_summary <- data.frame(
  Dictionary = c("Dictionnaire du Chilleur (DC)", "Fonds de données linguistiques du Québec (FDLC)"),
  MUEV_Count = c(
    sum(df$MUEV == TRUE & df$DC == TRUE),  # MUEV counts in DC
    sum(df$MUEV == TRUE & df$FDLC == TRUE)  # MUEV counts in FDLC
  )
)

# Bar plot to compare the counts
library(ggplot2)
ggplot(muev_summary, aes(x = Dictionary, y = MUEV_Count, fill = Dictionary)) +
  geom_bar(stat = "identity") +
  labs(title = "Comparison of MUEV Counts in DC and FDLC",
       x = "Dictionary", y = "MUEV Count") +
  theme_minimal() +
  scale_fill_brewer(palette = "Set1")

```

```{r}
data <- rename(data, DC = `In Dictionnaire du Chilleur (DC)`)
data <- rename(data, FDLQ = `In Fonds de données linguistiques du Québec (FDLQ)`)
```



```{r}
muev_summary <- data %>%
  filter(`MUEV or MIEV` == "MUEV") %>%
  group_by(DC, FDLQ) %>%
  summarise(MUEV_Count = n()) %>%
  pivot_longer(cols = MUEV_Count, names_to = "Count", values_to = "MUEV_Count")

# Bar plot to compare MUEV counts in DC and FDLC
ggplot(muev_summary, aes(x = interaction(DC, FDLQ), y = MUEV_Count, fill = interaction(DC, FDLQ))) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Comparison of MUEV Counts by Dictionary",
       x = "Dictionary", y = "MUEV Count") +
  scale_fill_brewer(palette = "Set1") +
  theme_minimal() 



```
```{r}
dc_tb <- table(data$`MUEV or MIEV`, data$DC, data$FDLQ)


collapsed_table <- apply(dc_tb, c(1, 2), sum)

# Run the Chi-squared test
chi_test <- chisq.test(collapsed_table)

# Display the results
cat("Chi-squared test result:\n")
print(chi_test)
```



```{r}
data$`In Dictionnaire du Chilleur (DC)`
```





# Categorical Variables: Chi-square or Fisher’s Exact Test
# Example: Verbal (Ir)Regularity by Verb Type
table_regularity <- table(your_data$verb_type, your_data$regularity)
chi_sq_test <- chisq.test(table_regularity)
# If the expected frequencies are too low, use Fisher’s Exact Test
# fisher_test <- fisher.test(table_regularity)

print(chi_sq_test)

# Continuous Variables: T-Test or mann whitery
# Example: Count by Verb Type
t_test <- t.test(count ~ verb_type, data = your_data)
mann_whitney <- wilcox.test(count ~ verb_type, data = your_data)

print(t_test)
print(mann_whitney)

# Visualization: Stacked Bar Plot for Categorical Comparison
your_data %>%
  group_by(verb_type, regularity) %>%
  summarize(n = n()) %>%
  ggplot(aes(x = verb_type, y = n, fill = regularity)) +
  geom_bar(stat = "identity", position = "stack", color = "black") +
  labs(
    title = "Comparison of Regularity by Verb Type",
    x = "Verb Type",
    y = "Count",
    fill = "Regularity"
  ) +
  theme_minimal()

# Visualization: Grouped Box Plot for Continuous Comparison
your_data %>%
  ggplot(aes(x = verb_type, y = count, fill = verb_type)) +
  geom_boxplot(alpha = 0.8) +
  labs(
    title = "Comparison of Count by Verb Type",
    x = "Verb Type",
    y = "Count"
  ) +
  theme_minimal() +
  theme(legend.position = "none")





























